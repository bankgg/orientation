<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Aircraft Orientation Test</title>
    <!-- Mobile-first -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />

    <!-- Bootstrap CSS -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.2/dist/css/bootstrap.min.css"
    />
    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.2/dist/js/bootstrap.bundle.min.js"></script>

    <style>
      .airplane-icon {
        width: 32px;
        transition: transform 0.3s ease;
      }
      .card.border-success {
        border: 2px solid #28a745 !important;
      }
      .card.border-danger {
        border: 2px solid #dc3545 !important;
      }
      /* Button coloring on submit */
      .choice-btn.correct {
        background-color: #28a745 !important;
        color: white !important;
        border-color: #28a745 !important;
      }
      .choice-btn.wrong {
        background-color: #dc3545 !important;
        color: white !important;
        border-color: #dc3545 !important;
      }
      .choice-btn.active {
        outline: 2px solid #007bff;
      }
    </style>
  </head>
  <body>
    <div class="container mt-4">
      <h1>Orientation Test</h1>

      <div class="mb-3">
        <button id="startTimer" class="btn btn-primary">Start Timer</button>
        <span id="timer" class="ml-3 font-weight-bold">00:00</span>
      </div>

      <div id="questions"></div>

      <!-- Full-width submit button with extra bottom margin -->
      <button id="submitBtn" class="btn btn-success btn-block mt-3 mb-3">
        Submit
      </button>
    </div>

    <!-- Result Modal -->
    <div
      class="modal fade"
      id="resultModal"
      tabindex="-1"
      role="dialog"
      aria-labelledby="resultModalTitle"
      aria-hidden="true"
    >
      <div class="modal-dialog modal-dialog-centered" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="resultModalTitle">Test Results</h5>
            <button
              type="button"
              class="close"
              data-dismiss="modal"
              aria-label="Close"
            >
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="modal-body">
            <p id="resultText"></p>
          </div>
          <div class="modal-footer">
            <button
              type="button"
              class="btn btn-secondary"
              data-dismiss="modal"
            >
              OK
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      let timerInterval = null;
      let secondsElapsed = 0;
      // Store user answers as an object (keys are question indices as strings)
      let userAnswers = {};

      /* --- Helper functions for answer normalization and comparison --- */

      // Parse an answer string (like "495R" or "180L" or "0") and return an object.
      // For non-zero answers, we return the normalized degree (mod 360).
      // If the normalized degree is 0, we return 0.
      // For the ambiguous case when moddeg === 180, we mark the direction as "amb".
      function parseAnswer(ans) {
        if (ans === "0") return { deg: 0, dir: "" };
        let match = ans.match(/^(\d+)([LR])$/);
        if (!match) return null;
        let num = parseInt(match[1], 10);
        let dir = match[2];
        let moddeg = num % 360;
        if (moddeg === 0) return { deg: 0, dir: "" };
        // Mark ambiguous if moddeg is 180.
        if (moddeg === 180) {
          return { deg: 180, dir: "amb" };
        }
        return { deg: moddeg, dir: dir };
      }

      // Compare two answer strings for equivalence after normalization.
      function answersEqual(ans1, ans2) {
        let a = parseAnswer(ans1);
        let b = parseAnswer(ans2);
        if (!a || !b) return false;
        return (
          a.deg === b.deg && (a.deg === 0 || a.deg === 180 || a.dir === b.dir)
        );
      }

      // Check if an answer is ambiguous (i.e. normalized degree equals 180)
      function isAmbiguous(ans) {
        let a = parseAnswer(ans);
        return a && a.deg === 180;
      }

      /* --- End helper functions --- */

      // Generate a random multiple of 45 up to max (default 720)
      function generateRandomMultipleOf45(max = 720) {
        let multiples = [];
        for (let i = 45; i <= max; i += 45) {
          multiples.push(i);
        }
        return multiples[Math.floor(Math.random() * multiples.length)];
      }

      // Randomly pick "L" or "R"
      function generateRandomDirection() {
        return Math.random() < 0.5 ? "L" : "R";
      }

      // Format rotation as "0" or "<deg><dir>" (e.g., "90R", "180L")
      function formatRotation(deg, dir) {
        if (deg === 0) return "0";
        return deg + dir;
      }

      // Apply rotation to a heading (0..359), using the provided rotation and direction.
      function applyRotation(currentHeading, rotation, direction) {
        if (direction === "R") {
          return (currentHeading + rotation) % 360;
        } else {
          return (currentHeading - rotation + 360) % 360;
        }
      }

      // Determine minimal rotation from current heading to target heading.
      // Returns "0" if no rotation needed,
      // Otherwise, returns diff+"R" if diff<=180, else (360-diff)+"L".
      function getRotationFromTo(current, target) {
        let diff = (target - current + 360) % 360;
        if (diff === 0) {
          return "0";
        } else if (diff <= 180) {
          return diff + "R";
        } else {
          return 360 - diff + "L";
        }
      }

      // Generate one question object.
      function generateQuestion(index) {
        // 1) Random initial heading (multiples of 45: 0..315)
        let initialHeading = 45 * Math.floor(Math.random() * 8);

        // 2) Generate 5 random steps.
        let currentHeading = initialHeading;
        let steps = [];
        for (let i = 0; i < 5; i++) {
          let rot = generateRandomMultipleOf45();
          let dir = generateRandomDirection();
          steps.push(formatRotation(rot, dir));
          currentHeading = applyRotation(currentHeading, rot, dir);
        }

        // 3) Random final heading (multiples of 45: 0..315)
        let finalHeading = 45 * Math.floor(Math.random() * 8);

        // 4) Compute correct minimal rotation.
        let correctAnswer = getRotationFromTo(currentHeading, finalHeading);

        // 5) Generate 4 random distractors.
        let choices = [];
        function randomAnswer() {
          let deg = generateRandomMultipleOf45();
          let dir = generateRandomDirection();
          return formatRotation(deg, dir);
        }
        for (let i = 0; i < 4; i++) {
          let ans = randomAnswer();
          // Reject if the candidate is already in choices OR is equivalent to the correct answer.
          while (
            choices.some((c) => answersEqual(c, ans)) ||
            answersEqual(ans, correctAnswer)
          ) {
            ans = randomAnswer();
          }
          choices.push(ans);
        }
        // Place the correct answer among the first four choices (a-d).
        let correctIndex = Math.floor(Math.random() * 4);
        choices[correctIndex] = correctAnswer;

        return {
          index,
          initialHeading,
          steps,
          finalHeading,
          correctAnswer, // this is the normalized correct answer string (e.g., "135R" or "180R")
          realCorrectAnswer: correctAnswer, // stored for potential "None" questions
          choices,
        };
      }

      // Generate all questions.
      function generateAllQuestions(count = 30) {
        let questions = [];
        for (let i = 0; i < count; i++) {
          questions.push(generateQuestion(i + 1));
        }
        // Enforce ~25% of questions have correct answer "None".
        let noneCount = Math.floor(count * 0.25);
        let usedIndexes = [];
        while (usedIndexes.length < noneCount) {
          let r = Math.floor(Math.random() * count);
          if (!usedIndexes.includes(r)) {
            usedIndexes.push(r);
          }
        }
        usedIndexes.forEach((idx) => {
          let q = questions[idx];
          q.noneActualAnswer = q.correctAnswer;
          q.correctAnswer = "None";
          let newChoices = [];
          while (newChoices.length < 4) {
            let ans = randomAnswer();
            if (
              !newChoices.some((c) => answersEqual(c, ans)) &&
              !answersEqual(ans, q.noneActualAnswer)
            ) {
              newChoices.push(ans);
            }
          }
          q.choices = newChoices;
        });
        return questions;
      }

      // Random answer generator used for "None" questions.
      function randomAnswer() {
        let deg = generateRandomMultipleOf45();
        let dir = generateRandomDirection();
        return formatRotation(deg, dir);
      }

      // Render questions in HTML.
      function renderQuestions(questions) {
        let html = "";
        questions.forEach((q) => {
          html += `
      <div class="card mb-3" id="question-${q.index}">
        <div class="card-header">Question ${q.index}</div>
        <div class="card-body">
          <!-- Row of 7 items: original airplane, 5 steps, final airplane -->
          <div class="d-flex justify-content-around align-items-center w-100 flex-wrap mb-3">
            <div class="p-1 text-center">
              <img src="airplane.png" class="airplane-icon" style="transform: rotate(${q.initialHeading}deg);" />
            </div>
            <div class="p-1 text-center">
              <span class="badge badge-primary">${q.steps[0]}</span>
            </div>
            <div class="p-1 text-center">
              <span class="badge badge-primary">${q.steps[1]}</span>
            </div>
            <div class="p-1 text-center">
              <span class="badge badge-primary">${q.steps[2]}</span>
            </div>
            <div class="p-1 text-center">
              <span class="badge badge-primary">${q.steps[3]}</span>
            </div>
            <div class="p-1 text-center">
              <span class="badge badge-primary">${q.steps[4]}</span>
            </div>
            <div class="p-1 text-center">
              <img src="airplane.png" class="airplane-icon" style="transform: rotate(${q.finalHeading}deg);" />
            </div>
          </div>
          <div class="btn-group-vertical w-100" role="group">
      `;

          let labels = ["a", "b", "c", "d", "e"];
          for (let i = 0; i < 5; i++) {
            let choiceText = i < 4 ? q.choices[i] : "None";
            html += `
            <button type="button" 
                    class="btn btn-sm btn-outline-primary choice-btn text-left mb-1"
                    data-qindex="${q.index}" 
                    data-choice="${choiceText}">
              ${labels[i]}) ${choiceText}
            </button>
        `;
          }

          html += `
          </div>
        </div>
      </div>
      `;
        });
        $("#questions").html(html);

        // Use .attr() to get the attributes so that type conversion issues are avoided.
        $(".choice-btn").click(function () {
          let qIndex = $(this).attr("data-qindex");
          let choiceValue = $(this).attr("data-choice");
          userAnswers[qIndex] = choiceValue;
          $(this)
            .closest(".btn-group-vertical")
            .find(".choice-btn")
            .removeClass("active");
          $(this).addClass("active");
        });
      }

      // Timer functions.
      function startTimer() {
        if (timerInterval) {
          clearInterval(timerInterval);
        }
        secondsElapsed = 0;
        $("#timer").text("00:00");
        timerInterval = setInterval(() => {
          secondsElapsed++;
          let minutes = Math.floor(secondsElapsed / 60);
          let seconds = secondsElapsed % 60;
          let mm = minutes < 10 ? "0" + minutes : minutes;
          let ss = seconds < 10 ? "0" + seconds : seconds;
          $("#timer").text(`${mm}:${ss}`);
        }, 1000);
      }

      function stopTimer() {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
      }

      $(document).ready(function () {
        let questions = generateAllQuestions(30);
        renderQuestions(questions);

        $("#startTimer").click(function () {
          startTimer();
        });

        $("#submitBtn").click(function () {
          stopTimer();
          let correctCount = 0;
          questions.forEach((q) => {
            let selected = userAnswers[String(q.index)] || null;
            let correct = q.correctAnswer;
            let questionCard = $(`#question-${q.index}`);
            // Compare using our normalization comparison
            if (
              selected !== null &&
              (correct === "None"
                ? selected === "None"
                : answersEqual(selected, correct))
            ) {
              correctCount++;
              questionCard
                .removeClass("border-danger")
                .addClass("border-success");
            } else {
              questionCard
                .removeClass("border-success")
                .addClass("border-danger");
            }
            questionCard.find(".choice-btn").each(function () {
              let btnChoice = $(this).attr("data-choice");
              $(this).removeClass("active");
              if (btnChoice === selected) {
                if (
                  correct === "None"
                    ? selected === "None"
                    : answersEqual(btnChoice, correct)
                ) {
                  $(this).addClass("correct");
                } else {
                  $(this).addClass("wrong");
                }
              }
              if (correct !== "None" && answersEqual(btnChoice, correct)) {
                $(this).addClass("correct");
              }
              // For "None" questions, also show the actual rotation.
              if (
                correct === "None" &&
                btnChoice === "None" &&
                q.noneActualAnswer
              ) {
                let labelText = $(this).text();
                if (!labelText.includes("(Actual:")) {
                  $(this).text(
                    labelText + " (Actual: " + q.noneActualAnswer + ")"
                  );
                }
              }
            });
          });

          let totalQuestions = questions.length;
          let percentage = ((correctCount / totalQuestions) * 100).toFixed(1);
          let minutes = Math.floor(secondsElapsed / 60);
          let seconds = secondsElapsed % 60;
          let mm = minutes < 10 ? "0" + minutes : minutes;
          let ss = seconds < 10 ? "0" + seconds : seconds;
          let timeString = `${mm}:${ss}`;
          let resultMsg = `Time: ${timeString}<br/>
                       Correct: ${correctCount}/${totalQuestions} (${percentage}%)`;
          $("#resultText").html(resultMsg);
          window.scrollTo(0, 0);
          $("#resultModal").modal("show");
        });
      });
    </script>
  </body>
</html>
